from sklearn.ensemble import RandomForestClassifier
from sklearn.neural_network import MLPClassifier
from sklearn import linear_model, svm, tree
from sklearn.model_selection import train_test_split
import numpy as np
import joblib
import paddle
import paddle.fluid as fluid

from sklearn.ensemble import RandomForestClassifier
from sklearn.neural_network import MLPClassifier
from sklearn import linear_model, svm, tree
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import numpy as np

import datasets


class VOTEClassifier():
    def __init__(self):
        self.RF = RandomForestClassifier(n_estimators=50, max_depth=5, random_state=1)
        self.SVM = svm.SVC()
        self.LR = linear_model.LogisticRegression()
        self.DT = tree.DecisionTreeRegressor()
        self.MLP = MLPClassifier(hidden_layer_sizes=(50,), max_iter=10, alpha=1e-4,
                                 solver='sgd', verbose=0, tol=1e-4, random_state=1,
                                 learning_rate_init=0.1)
        # 5个分类器比例均等
        self.alpha = 0.2 * np.ones((5, ))

    def fit(self, X, y):
        xtrain, xtest, ytrain, ytest = train_test_split(X, y, test_size=0.20)
        self.RF.fit(xtrain, ytrain)
        self.SVM.fit(xtrain, ytrain)
        self.LR.fit(xtrain, ytrain)
        self.DT.fit(xtrain, ytrain)
        self.MLP.fit(xtrain, ytrain)
        RF_score = self.RF.score(xtest, ytest)
        SVM_score = self.SVM.score(xtest, ytest)
        LR_score = self.LR.score(xtest, ytest)
        DT_score = self.DT.score(xtest, ytest)
        MLP_score = self.MLP.score(xtest, ytest)
        self.alpha = np.array([RF_score, SVM_score, LR_score, DT_score, MLP_score]) ** 5
        self.alpha = self.alpha / np.sum(self.alpha)

    def predict(self, X):
        RF_predict = self.RF.predict(X)
        SVM_predict = self.SVM.predict(X)
        LR_predict = self.LR.predict(X)
        DT_predict = self.DT.predict(X)
        MLP_predict = self.MLP.predict(X)
        VOTE_predict = self.alpha[0]*RF_predict + self.alpha[1]*SVM_predict + self.alpha[2]*LR_predict + \
                       self.alpha[3]*DT_predict + self.alpha[4]*MLP_predict
        VOTE_predict = np.ones(VOTE_predict.shape) * (VOTE_predict>0.5)
        return VOTE_predict

    # def score(self, X, y):
    #     from sklearn.metrics import accuracy_score
    #     return accuracy_score(y, self.predict(X), sample_weight=None)
# save model to disk 保存模型 classifier
def save_model(model, save_name, save_path='saved_model'):
    joblib.dump(value=model, filename=save_path + '/' + save_name, compress=True)
    print("model has saved!!")


# load model from disk 加载模型 classifier
def load_model(file_name, file_path='saved_model'):
    model = joblib.load(filename=file_path + '/' + file_name)
    return model


# 替代检测器
class substitute_detector(fluid.dygraph.Layer):

    def __init__(self, layers=[4000, 4096, 2]):
        super(substitute_detector, self).__init__()
        trainable = True
        self._fc_list = []
        for i in range(len(layers) - 1):
            fc = self.add_sublayer(
                'fc_%d' % (i + 1),
                fluid.dygraph.Linear(
                    input_dim=layers[i],
                    output_dim=layers[i + 1],
                    param_attr=fluid.ParamAttr(trainable=trainable)
                )
            )
            self._fc_list.append(fc)

    def forward(self, x):
        for fc in self._fc_list:
            x = fc(x)
        x = fluid.layers.softmax(x)
        return x

    def predict(self, x):
        with fluid.dygraph.guard(place=fluid.CUDAPlace(0)):
            self.eval()
            x = fluid.dygraph.to_variable(x)
            preds = self.forward(x)
            preds = preds.numpy()[:, 1]
            preds = np.ones(preds.shape) * (preds > 0.5)
            return preds

    def train_on_batch(self, x_batch, y_batch, lr):
        with fluid.dygraph.guard(place=fluid.CUDAPlace(0)):
            self.train()
            optimizer = fluid.optimizer.AdamOptimizer(learning_rate=lr, parameter_list=self.parameters())
            x = fluid.dygraph.to_variable(x_batch)
            y = fluid.dygraph.to_variable(y_batch.reshape(-1, 1))
            preds = self.forward(x)
            loss = fluid.layers.cross_entropy(preds, y)
            acc = fluid.layers.accuracy(preds, y)
            avg_loss = fluid.layers.mean(loss)
            avg_acc = fluid.layers.mean(acc)
            result = [avg_loss.numpy()[0], avg_acc.numpy()[0]]
            avg_loss.backward()
            optimizer.minimize(avg_loss)
            self.clear_gradients()
            return result

    def save_params(self, name):
        path = './params/'
        fluid.save_dygraph(self.state_dict(), path + name)

    def load_params(self, name):
        path = './params/'
        params_dict, _ = fluid.load_dygraph(path + name)
        self.set_dict(params_dict)


# 生成器
class generator(fluid.dygraph.Layer):

    def __init__(self, layers):
        super(generator, self).__init__()
        self._fc_list = []
        for i in range(len(layers) - 1):
            fc = self.add_sublayer(
                'fc_%d' % (i + 1),
                fluid.dygraph.Linear(
                    input_dim=layers[i],
                    output_dim=layers[i + 1]
                )
            )
            self._fc_list.append(fc)

    def forward(self, inputs):
        example, noise = inputs[0], inputs[1]
        x = fluid.layers.concat([example, noise], axis=1)
        for fc in self._fc_list:
            x = fc(x)
        x = fluid.layers.sigmoid(x)
        x = fluid.layers.elementwise_max(example, x)
        return x

    def predict(self, inputs):
        with fluid.dygraph.guard(place=fluid.CUDAPlace(0)):
            self.eval()
            inputs = [fluid.dygraph.to_variable(inputs[0]), fluid.dygraph.to_variable(inputs[1])]
            preds = self.forward(inputs)
            preds = preds.numpy()
            return preds

    def save_params(self, name):
        path = 'params/'
        fluid.save_dygraph(self.state_dict(), path + name)

    def load_params(self, name):
        path = 'params/'
        params_dict, _ = fluid.load_dygraph(path + name)
        self.set_dict(params_dict)


# combined model
class combined(fluid.dygraph.Layer):

    def __init__(self, generator, substitute_detector):
        super(combined, self).__init__()
        self.generator = generator
        self.substitute_detector = substitute_detector

    def forward(self, inputs):
        malware_examples = self.generator(inputs)
        validity = self.substitute_detector(malware_examples)
        return validity

    def train_on_batch(self, x_batch, y_batch, lr):
        with fluid.dygraph.guard(place=fluid.CUDAPlace(0)):
            self.train()
            optimizer = fluid.optimizer.AdamOptimizer(learning_rate=lr, parameter_list=self.parameters())
            x = [fluid.dygraph.to_variable(x_batch[0]), fluid.dygraph.to_variable(x_batch[1])]
            y = fluid.dygraph.to_variable(y_batch.reshape(-1, 1))
            preds = self.forward(x)
            loss = fluid.layers.cross_entropy(preds, y)
            avg_loss = fluid.layers.mean(loss)
            result = avg_loss
            avg_loss.backward()
            optimizer.minimize(avg_loss)
            self.clear_gradients()
            return result

    def save_params(self, name):
        path = 'params/'
        fluid.save_dygraph(self.state_dict(), path + name)

    def load_params(self, name):
        path = 'params/'
        params_dict, _ = fluid.load_dygraph(path + name)
        self.set_dict(params_dict)


class MalGAN():
    def __init__(self, blackbox='RF', same_train_data=1, filename='datatest.npz'):
        self.apifeature_dims = 135
        self.z_dims = 20
        self.hide_layers = 256
        self.lr = 0.0000001
        self.generator_layers = [self.apifeature_dims + self.z_dims, self.hide_layers, self.apifeature_dims]
        self.substitute_detector_layers = [self.apifeature_dims, self.hide_layers, 2]
        # RF LR DT SVM MLP VOTE
        self.blackbox = blackbox
        # MalGAN and the black-boxdetector are trained on same or different training sets
        self.same_train_data = same_train_data
        self.filename = filename

        # Build and Train blackbox_detector
        self.blackbox_detector = self.build_blackbox_detector()
        # Build and compile the substitute_detector
        self.substitute_detector = substitute_detector(self.substitute_detector_layers)
        # Build the generator
        self.generator = generator(self.generator_layers)
        # The generator takes malware and noise as input and generates adversarial malware examples
        self.combined = combined(self.generator, self.substitute_detector)

    # black_detector黑盒检测器
    def build_blackbox_detector(self):

        if self.blackbox is 'RF':
            blackbox_detector = RandomForestClassifier(n_estimators=500, max_depth=3, random_state=1)
        elif self.blackbox is 'SVM':
            blackbox_detector = svm.SVC()
        elif self.blackbox is 'LR':
            blackbox_detector = linear_model.LogisticRegression()
        elif self.blackbox is 'DT':
            blackbox_detector = tree.DecisionTreeRegressor()
        elif self.blackbox is 'MLP':
            blackbox_detector = MLPClassifier(hidden_layer_sizes=(50,), max_iter=10, alpha=1e-4,
                                              solver='sgd', verbose=0, tol=1e-4, random_state=1,
                                              learning_rate_init=0.001)
        elif self.blackbox is 'VOTE':
            blackbox_detector = VOTEClassifier()

        return blackbox_detector

    # 加载数据
    def load_data(self):

        xben, yben, benfile_names = datasets.csv2numpy(r'I:\论文\文档型\PDF\代码\Malware-GAN\testdata\contagio-ben.csv')
        xmal, ymal, malfile_names = datasets.csv2numpy(r'I:\论文\文档型\PDF\代码\Malware-GAN\testdata\contagio-mal.csv')
        # print('this is xben:', xben)
        return (xmal, ymal), (xben, yben)

    # 训练函数
    def train(self, epochs, batch_size=32, is_first=1):

        np.seterr(divide='ignore', invalid='ignore')
        # Load and Split the dataset (加载并划分数据集)
        (xmal, ymal), (xben, yben) = self.load_data()
        xtrain_mal, xtest_mal, ytrain_mal, ytest_mal = train_test_split(xmal, ymal, test_size=0.20)
        xtrain_ben, xtest_ben, ytrain_ben, ytest_ben = train_test_split(xben, yben, test_size=0.20)

        # 训练集的两种分割方式
        #      same_train_data决定了black detector以及substitude detector是否使用相同的训练数据
        #      依据same_train_data, 一种black detector以及substitude detector共用这部分训练集，
        # 另一种训练集进一步对半分，分别作为black detector以及substitude detector的训练集。
        if self.same_train_data:
            bl_xtrain_mal, bl_ytrain_mal, bl_xtrain_ben, bl_ytrain_ben = xtrain_mal, ytrain_mal, xtrain_ben, ytrain_ben
        else:
            xtrain_mal, bl_xtrain_mal, ytrain_mal, bl_ytrain_mal = train_test_split(xtrain_mal, ytrain_mal,
                                                                                    test_size=0.50)
            xtrain_ben, bl_xtrain_ben, ytrain_ben, bl_ytrain_ben = train_test_split(xtrain_ben, ytrain_ben,
                                                                                    test_size=0.50)

        # if is_first is Ture, Train the blackbox_detctor
        if is_first:
            self.blackbox_detector.fit(np.concatenate([xmal, xben]),
                                       np.concatenate([ymal, yben]))

        ytrain_ben_blackbox = self.blackbox_detector.predict(bl_xtrain_ben)
        Original_Train_TPR = self.blackbox_detector.score(bl_xtrain_mal, bl_ytrain_mal)
        Original_Test_TPR = self.blackbox_detector.score(xtest_mal, ytest_mal)
        Train_TPR, Test_TPR = [Original_Train_TPR], [Original_Test_TPR]
        best_TPR = 1.0

        for epoch in range(epochs):

            for step in range(xtrain_mal.shape[0] // batch_size):
                # ---------------------
                #  Train substitute_detector
                # ---------------------

                # Select a random batch of malware examples
                # 采样生成小批量malware样本M
                # 一个random batch的索引列表
                idx = np.random.randint(0, xtrain_mal.shape[0], batch_size)
                # 由索引取出一个batch
                xmal_batch = xtrain_mal[idx].astype('float32')
                # 随机初始化噪声
                noise = np.random.uniform(0, 1, (batch_size, self.z_dims)).astype('float32')

                # 采样生成小批量benign样本B
                idx = np.random.randint(0, xmal_batch.shape[0], batch_size)
                xben_batch = xtrain_ben[idx].astype('float32')
                # 利用black-box detector对B打上标签
                yben_batch = ytrain_ben_blackbox[idx].astype('int64')

                # Generate a batch of new malware examples
                # generator输入M生成对抗样本M’
                gen_examples = self.generator.predict([xmal_batch, noise])
                gen_examples = gen_examples.astype('float32')

                # 利用blcak-box detector对M’打上标签
                ymal_batch = self.blackbox_detector.predict(np.ones(gen_examples.shape) * (gen_examples > 0.5))
                ymal_batch = ymal_batch.astype('int64')

                # Train the substitute_detector
                # 训练替代检测器
                d_loss_real = self.substitute_detector.train_on_batch(gen_examples, ymal_batch, self.lr)
                d_loss_fake = self.substitute_detector.train_on_batch(xben_batch, yben_batch, self.lr)
                d_loss = 0.5 * np.add(d_loss_real, d_loss_fake)

                # ---------------------
                #  Train Generator
                # ---------------------

                idx = np.random.randint(0, xtrain_mal.shape[0], batch_size)
                xmal_batch = xtrain_mal[idx].astype('float32')
                noise = np.random.uniform(0, 1, (batch_size, self.z_dims)).astype('float32')

                # Train the generator
                self.substitute_detector.trainable = False
                g_loss = self.combined.train_on_batch([xmal_batch, noise], np.zeros((batch_size, 1)).astype('int64'),
                                                      self.lr)
                self.substitute_detector.trainable = True

            # Compute Train TPR
            noise = np.random.uniform(0, 1, (xtrain_mal.shape[0], self.z_dims))
            gen_examples = self.generator.predict([xtrain_mal.astype('float32'), noise.astype('float32')])
            TPR = self.blackbox_detector.score(np.ones(gen_examples.shape) * (gen_examples > 0.5), ytrain_mal)
            Train_TPR.append(TPR)

            # Compute Test TPR
            noise = np.random.uniform(0, 1, (xtest_mal.shape[0], self.z_dims))
            gen_examples = self.generator.predict([xtest_mal.astype('float32'), noise.astype('float32')])
            TPR = self.blackbox_detector.score(np.ones(gen_examples.shape) * (gen_examples > 0.5), ytest_mal)
            Test_TPR.append(TPR)

            # Save best model
            if TPR < best_TPR:
                self.combined.save_params('malgan')
                best_TPR = TPR

            # Plot the progress
            if is_first:
                print("%d [D loss: %f, acc.: %.2f%%] [G loss: %f]" % (epoch, d_loss[0], 100 * d_loss[1], g_loss))

        flag = ['DiffTrainData', 'SameTrainData']
        print('\n\n---{0} {1}'.format(self.blackbox, flag[self.same_train_data]))
        print('\nOriginal_Train_TPR: {0}, Adver_Train_TPR: {1}'.format(Original_Train_TPR, Train_TPR[-1]))
        print('\nOriginal_Test_TPR: {0}, Adver_Test_TPR: {1}'.format(Original_Test_TPR, Test_TPR[-1]))

        print('self.apifeature_dims = ', self.apifeature_dims)
        print('self.z_dims = ', self.z_dims)
        print('self.hide_layers = ', self.hide_layers)
        print('learningrate = ', self.lr)

        # Plot TPR
        plt.figure()
        plt.plot(range(len(Train_TPR)), Train_TPR, c='r', label='Training Set', linewidth=2)
        plt.plot(range(len(Test_TPR)), Test_TPR, c='g', linestyle='--', label='Validation Set', linewidth=2)
        plt.xlabel('Epoch')
        plt.ylabel('TPR')
        plt.legend()
        plt.savefig('saves/Epoch_TPR({0}, {1}).png'.format(self.blackbox, flag[self.same_train_data]))
        plt.show()

    # 重训练黑盒检测器
    def retrain_blackbox_detector(self):
        np.seterr(divide='ignore', invalid='ignore')
        (xmal, ymal), (xben, yben) = self.load_data()
        xtrain_mal, xtest_mal, ytrain_mal, ytest_mal = train_test_split(xmal, ymal, test_size=0.20)
        xtrain_ben, xtest_ben, ytrain_ben, ytest_ben = train_test_split(xben, yben, test_size=0.20)
        # Generate Train Adversarial Examples
        # 生成对抗样本
        noise = np.random.uniform(0, 1, (xtrain_mal.shape[0], self.z_dims))
        gen_examples = self.generator.predict([xtrain_mal.astype('float32'), noise.astype('float32')])
        gen_examples = np.ones(gen_examples.shape) * (gen_examples > 0.5)
        gen_examples = gen_examples.astype('float32')
        print(gen_examples.shape)
        # 训练
        self.blackbox_detector.fit(np.concatenate([xtrain_mal, xtrain_ben, gen_examples]),
                                   np.concatenate([ytrain_mal, ytrain_ben, ytrain_mal]))

        # 评估
        # Compute Train TPR
        train_TPR = self.blackbox_detector.score(gen_examples, ytrain_mal)

        # Compute Test TPR
        noise = np.random.uniform(0, 1, (xtest_mal.shape[0], self.z_dims))
        gen_examples = self.generator.predict([xtest_mal.astype('float32'), noise.astype('float32')])
        gen_examples = np.ones(gen_examples.shape) * (gen_examples > 0.5)
        gen_examples = gen_examples.astype('float32')
        test_TPR = self.blackbox_detector.score(gen_examples, ytest_mal)
        print('\n---TPR after the black-box detector is retrained(Before Retraining MalGAN).')
        print('\nTrain_TPR: {0}, Test_TPR: {1}'.format(train_TPR, test_TPR))

        # 保存模型
        save_model(self.blackbox_detector, 'retrain_' + self.blackbox)
if __name__ == '__main__':
    np.random.seed(0)
    malgan = MalGAN(blackbox='RF')
    malgan.train(epochs=200, batch_size=64)

    malgan.retrain_blackbox_detector()
    # malgan.train(epochs=200, batch_size=64, is_first=False)
